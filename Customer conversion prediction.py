# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sMryOzaJfposbCu_G0uZCDAAri3x77qr
"""



"""## **Customer Conversion Prediction**

# **Problem Statement**

You are working for a new-age insurance company and employ mutiple outreach plans to sell term insurance to your customers. Telephonic marketing campaigns still remain one of the most effective way to reach out to people however they incur a lot of cost. Hence, it is important to identify the customers that are most likely to convert beforehand so that they can be specifically targeted via call. We are given the historical marketing data of the insurance company and are required to build a ML model that will predict if a client will subscribe to the insurance.

# **Features:**

*age (numeric)

*job : type of job

*marital : marital status

*educational_qual : education status

*call_type : contact communication type

*day: last contact day of the month (numeric)

*mon: last contact month of year

*dur: last contact duration, in seconds (numeric)

*num_calls: number of contacts performed during this campaign and for this client

*prev_outcome: outcome of the previous marketing campaign (categorical:

*"unknown","other","failure","success")

*Output variable (desired target): y - has the client subscribed to the insurance?

# **Basic Analysis of Dataset from Problem Statement and Features**

*It is a supervised learning problem - We are predicting target variable
From target varible we can clearly understand it is a classification problem

*From target variable we can tell it is a binary classification problem. target = (y/n)

# **Importing Libraries**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

#To ignore warnings
import warnings
warnings.filterwarnings("ignore")

"""# **Loading Dataset**"""

df=pd.read_csv("Customer Conversion Prediction - Customer Conversion Prediction.csv")

"""# **Analysis of Data**"""

# Checking size of dataset
print("Data set size : ", df.shape)

"""From the above result no of rows are 45211 and no of columns are 11"""

#Fetching top 5 row in dataset
df.head()

#Fetching Bottom 5 rows
df.tail()

#finding the column names
df.columns

#Basic statistical analysis of dataset
df.describe()

"""From statistical result we can understatnd the basic statistical report of min, max, percentile, mean and standard deviation"""

#checking for the data is balanced or not
df['y'].value_counts()

"""From the above result we can clearly understand that the dataset is imbalanced. Lets find the percentage.

# **Data Preprocessing**

**Data Cleaning**

Data cleaning is the process of identifying and correcting or removing errors, inconsistencies, and inaccuracies in a dataset to improve its quality and ensure that it is ready for analysis. It involves tasks such as handling missing or duplicate data, correcting data types, and removing outliers or irrelevant information.

# **Missing Values**
"""

#checking for null values
df.isnull().sum()

"""# **Finding Duplicate Value**s"""

#checking for no of duplicate values
df.duplicated().sum()

"""From the above result we can find 6 duplicate datas. So will drop the duplicates."""

#droping duplicates
df = df.drop_duplicates()

#after droping agin check for no of duplicates
df.duplicated().sum()

"""Duplicates are removed from dataset.

**Checking Data Type**
"""

df.dtypes

"""There is no need to change any datatype of the columns

# **Unique Values of Categorical Column**
"""

print("Unique values of Job \n")
print(df['job'].unique())

print("Unique values of Marital Status \n")
print(df['marital'].unique())

print("Unique values of Educationsl Qualification \n")
print(df['education_qual'].unique())

print("Unique values of Call Type \n")
print(df['call_type'].unique())

print("Unique values of Month \n")
print(df['mon'].unique())

print("Unique values of Previous Outcome \n")
print(df['prev_outcome'].unique())

print("Unique values of Target Variable 'y' \n")
print(df['y'].unique())

"""# **Exploring the Dataset and replace the unknown values**

**Converting categorical Target column into numerical column.**
"""

df['target'] = df["y"].map({"yes":1 , "no": 0})

df.head()

"""# **Age**"""

#no of counts for particular age 
df.age.value_counts()

#checking for the percentage of how many people get insured? compared with Target vs Age
df.groupby('age')['target'].mean()

"""# **Job**"""

#no of counts for particular job
df.job.value_counts()

#checking for the percentage of how many people get insured? compared with Target vs Job
df.groupby('job')['target'].mean()

# droping the column unknown 
#outof 45211 rows, deletion of 288 rows will not get more impact on dataset so planning to delete

#replacing unknown value as null
df['job'] =df['job'].replace('unknown',np.nan)

#counting the no of null value in jab column
df.job.isnull().sum()

#removing null values from job column
df=df.dropna(subset=['job'])

#after removing null values checking for the summ of null vaues
df.job.isnull().sum()

"""**Marital Status**"""

#no of counts for marital status
df.marital.value_counts()

#checking for the percentage of how many people get insured? compared with Target vs Marital Status
df.groupby('marital')['target'].mean()

"""**Educational Qualification**"""

#no of counts for Educational qualification
df.education_qual.value_counts()

#checking for the percentage of how many people get insured? compared with Target vs Educational Qualification
df.groupby('education_qual')['target'].mean()

#Finding the percentage of unknown value
print('Percentage for "Unknown": ',((1730) / (23202+13301+6851+1730)) * 100 )

"""Unknown percentage is 3.8% so if we delete also it will note affect the dataset"""

#replacing unknown value as null
df['education_qual'] =df['education_qual'].replace('unknown',np.nan)

#checking for null values
df.education_qual.isnull().sum()

#droping the null values
df = df. dropna(subset=['education_qual'])

#checking for null value after deleting
df.education_qual.isnull().sum()

"""# **Call Type**"""

#no of counts for Call type
df.call_type.value_counts()

#checking for the percentage of how many people get insured? compared with Target vs Call Type
df.groupby('call_type')['target'].mean()

#Finding the percentage of unknown value
print('Percentage for "Unknown": ',((12283) / (29285+13020+12283)) * 100 )

"""Unknown call type percentage is 22.50% so we will keep as it is.

**Day**
"""

#no of counts for Day
df.day.value_counts()

#checking for the percentage of how many people get insured? compared with Target vs Day
df.groupby('day')['target'].mean()

"""**Month**"""

#checking for the percentage of how many people get insured? compared with Target vs Month
df.groupby('mon')['target'].mean()

#no of counts for duration
df.dur.value_counts()

#checking for the percentage of how many people get insured? compared with Target vs Duration
df.groupby('dur')['target'].mean()

"""**Number of Calls**"""

#no of counts for number of calls
df.num_calls.value_counts()

#checking for the percentage of how many people get insured? compared with Target vs Numer of Calls
df.groupby('num_calls')['target'].mean()

"""**Previous Outcome**"""

#no of counts for previous outcome
df.prev_outcome.value_counts()

#checking for the percentage of how many people get insured? compared with Target vs Previous outcome
df.groupby('prev_outcome')['target'].mean()

#Finding the percentage of unknown value
print('Percentage for "Unknown": ',((35280) / (35280+4709+1774+1424)) * 100 )

"""It is around 81% values are unknown. So will keep unknown value as it is.

**Target Variable Y**
"""

#no of counts of target variable y
df.y.value_counts()

df.info()

"""# **Outlier Deduction and Correction**


**Outlier Detection**

1.Z-Score Z-Score(x)=(x-mean(x)) / SD(x) Threshold Limit Z-Score > 3 and 
Z-Score < -3 ---> Outlier
2.IQR IQR = Q3(75%)-Q1(25%) Upper Threshold = Q3 + (1.5 * IQR) Lower Threshold = Q1 - (1.5 * IQR)
3.Plotting Box Plot

**Outlier Correction** 

1.   List item
2.   Clip/Strip


Clip/Strip
"""

df.info()

"""# **Age**

**Box Plot**
"""

#Outlier Detuction using Box Plot for Age Column
sns.set(style="whitegrid")
sns.boxplot(x=df['age'], color='Chartreuse')

"""From outlier we can see that there are many dots are displayed outside whisker

# **IQR**
"""

#detecting Outlier for Age column
q1,q3=np.percentile(df["age"],[25,75])
IQR=q3-q1
upper=q3+1.5*IQR
lower=q1-1.5*IQR
print("Upper age bound:",upper,"Lower age bound :", lower)

"""# **Removing outlier for Age**"""

#removing outlier for age column
# Clip/ Strip is used to detuct value to lower & upper threshold.
df.age = df.age.clip(10.5,70.5)

df.age.describe()

"""**Checking- After outlier removal**"""

sns.set(style="whitegrid")
sns.boxplot(x=df['age'], color='Chartreuse')

"""# **Day**

**BOX PLOT**
"""

#Outlier Detuction using Box Plot for day Column
sns.set(style="whitegrid")
sns.boxplot(x=df['day'], color='Chartreuse')

"""**IQR**"""

#detecting Outlier for Age column
q1,q3=np.percentile(df["day"],[25,75])
IQR=q3-q1
upper=q3+1.5*IQR
lower=q1-1.5*IQR
print("Upper bound:",upper,"Lower bound :", lower)

df.day.describe()

"""From Box plot itself we can tell there is no outlier, even though checked with IQR approach. min and max values are in between lower and upper bound.

# **Duration**


**Box Plot**
"""

#Outlier Detuction using Box Plot for duration Column
sns.set(style="whitegrid")
sns.boxplot(df['dur'], color='Chartreuse')

"""**IQR**"""

#detecting Outlier for Duration column
q1,q3=np.percentile(df["dur"],[25,75])
IQR=q3-q1
upper=q3+1.5*IQR
lower=q1-1.5*IQR
print("Upper bound:",upper,"Lower bound :", lower)

"""**Removing Outlier for duration column**"""

#removing outlier for duration column
# Clip/ Strip is used to detuct value to lower & upper threshold.
df.dur = df.dur.clip(-219.5,640.5)

df.dur.describe()

"""**Checking after outlier removal**"""

sns.set(style="whitegrid")
sns.boxplot(df['dur'], color='Chartreuse')

"""# **No of Calls**


**Box Plot**
"""

#checking for outlier using boxplot fot the column no of calls
sns.set(style="whitegrid")
sns.boxplot(df['num_calls'], color='Chartreuse')

"""**IQR**"""

#detecting Outlier for number of calls column
q1,q3=np.percentile(df["num_calls"],[25,75])
IQR=q3-q1
upper=q3+1.5*IQR
lower=q1-1.5*IQR
print("Upper bound:",upper,"Lower bound :", lower)

#removing outlier for num_calls column
# Clip/ Strip is used to detuct value to lower & upper threshold.
df.num_calls = df.num_calls.clip(-2,6.0)

df.num_calls.describe()

"""# **Checking after outlier removal**"""

sns.set(style="whitegrid")
sns.boxplot(df['num_calls'], color='Chartreuse')

"""we detucted and removed outlier for all numerical columns. So we are done with Data Cleaning Process.

# **EDA - Exploratory Data Analysis**

EDA is an important step in the data analysis process, as it helps to identify potential issues with the data and to develop a deeper understanding of the relationships between variables.

**Distribution of Feature and Target variable**
"""

# Age distribution 
plt.figure(figsize = (20,20),dpi=180)  
plt.subplot(3,4,1) 
sns.histplot((df.age),color='BlueViolet')

# Get the current Axes object
ax = plt.gca()

# Calculate and annotate the percentage of each category
total = float(len(df['age']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

    plt.title('Age Distribution', fontsize = 12, color='maroon', fontweight='bold') 
plt.xlabel('Age',fontsize = 12, color='green') 
plt.ylabel('Count',fontsize = 12, color='green')  


# Get the current Axes object
ax = plt.gca()

# Calculate and annotate the percentage of each category
total = float(len(df['job']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

    plt.title('Job Distribution', fontsize = 14, color="maroon", fontweight='bold') 
plt.xlabel('Type Of Job',fontsize = 12, color='green') 
plt.xticks(rotation = 90) 
plt.ylabel('Count',fontsize = 12, color='green')  



# Get the current Axes object
ax = plt.gca()


# Calculate and annotate the percentage of each category
total = float(len(df['marital']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

    plt.title('Marital Status Distribution', fontsize = 14, color='maroon', fontweight='bold') 
plt.xlabel('Marital',fontsize = 12, color='green') 
plt.xticks(rotation = 90) 
plt.ylabel('Count',fontsize = 12, color='green')  




# Get the current Axes object
ax = plt.gca()


# Calculate and annotate the percentage of each category
total = float(len(df['education_qual']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

    plt.title('Education Qualification', fontsize = 14, color='maroon', fontweight='bold') 
plt.xlabel('Education',fontsize = 12, color='green') 
plt.xticks(rotation = 90) 
plt.ylabel('Count',fontsize = 12, color='green') 



# Get the current Axes object
ax = plt.gca()

# Calculate and annotate the percentage of each category
total = float(len(df['call_type']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')


    plt.title('Call Type', fontsize = 14, color='maroon', fontweight='bold') 
plt.xlabel('Call type',fontsize = 12, color='green') 
plt.xticks(rotation = 90) 
plt.ylabel('Count',fontsize = 12, color='green')  

# Day distribution 
plt.subplot(3,4,6) 
sns.histplot(df['day'], color="Fuchsia") 

# Get the current Axes object
ax = plt.gca()

# Calculate and annotate the percentage of each category
total = float(len(df['day']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

    plt.title('Day', fontsize = 14, color='maroon', fontweight='bold') 
plt.xlabel('Day',fontsize = 12, color='green') 
plt.xticks(rotation = 90,fontsize = 10) 
plt.ylabel('Count',fontsize = 12, color='green')  




# Get the current Axes object
ax = plt.gca()

# Calculate and annotate the percentage of each category
total = float(len(df['mon']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

plt.title('Month', fontsize = 14, color='maroon', fontweight='bold') 
plt.xlabel('Month',fontsize = 12, color='green') 
plt.xticks(rotation = 90) 
plt.ylabel('Count',fontsize = 12, color='green')  




# Dur distribution 
plt.subplot(3,4,8) 
sns.histplot((df.dur),color = 'cyan')

# Get the current Axes object
ax = plt.gca()

# Calculate and annotate the percentage of each category
total = float(len(df['dur']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

plt.title('Duration', fontsize = 14, color='maroon', fontweight='bold') 
plt.xlabel('Duration',fontsize = 12, color='green') 
plt.ylabel('Count',fontsize = 12, color='green')  




# Num call distribution 
plt.subplot(3,4,9) 
sns.histplot(df['num_calls']) 

# Get the current Axes object
ax = plt.gca()

# Calculate and annotate the percentage of each category
total = float(len(df['num_calls']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

plt.title('Number Of Calls', fontsize = 14, color='maroon', fontweight='bold') 
plt.xlabel('Number Of Calls',fontsize = 12, color='green') 
plt.xticks(rotation = 90) 
plt.ylabel('Count',fontsize = 12, color='green')  



# Get the current Axes object
ax = plt.gca()

# Calculate and annotate the percentage of each category
total = float(len(df['prev_outcome']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

plt.title('Previous Outcome', fontsize = 14, color='maroon', fontweight='bold') 
plt.xlabel('Previous Outcome',fontsize = 12, color='green') 
plt.xticks(rotation = 90) 
plt.ylabel('Count',fontsize = 12, color='green')  




# Get the current Axes object
ax = plt.gca()

# Calculate and annotate the percentage of each category
total = float(len(df['y']))
for p in ax.patches:
    height = p.get_height()
    percentage = '{:.1f}%'.format(100 * height/total)
    x = p.get_x() + p.get_width() / 2 - 0.1
    y = height + 5
    ax.text(x, y, percentage, fontsize=8, rotation=90, ha='center', va='bottom', color='Purple')

plt.title('Target Distribution', fontsize = 14, color='maroon', fontweight='bold') 
plt.xlabel('Target Distribution',fontsize = 12, color='green')
plt.xticks(rotation = 90) 
plt.ylabel('Count',fontsize = 12, color='green')  

plt.tight_layout()


plt.show()

"""**From the above plots we can clearly tell the following interpretation**

**1. Age**
Most Target : 30 to 40 years
Least Target : belove 20 and above 60
**2. Job**
Most Target : blue-collar and management
Least Target : students and house maid
**3. Marital Status**
Most Target : Maried
Least Target : Divorced
**4. Education**
Most Target : Secondary
Least Target : Primary
**5. Call Type**
Most Target : cellular
Least Target : telephone
**6. Day**
Most Target : Mid of the month
Least Target : Beginning of Month
**7. Month**
Most Target : May
Least Target : December
**8. Duration**
Most Target : call last around 1750 second
Least Target : call last around 100 to 200 second
**9. No of Calls**
Most Target : most people contacted one time
Least Target : least people contacted 5 times
**10. Previous Outcome**
Most Target : most people previous outcome was unknown
Least Target : Previous outcome for least people are success
**11. Target**
No of people insured is very less percentage (ie) 88 %, only few percentage are insured.

# **Features vs Target**

**Categorical Variable vs Target (Categorical) -- Job, Marital, Educational Qualification, Call Type, Month**
"""

plt.figure(figsize=(20,35), dpi=180)
#plt.suptitle("Categorical Data Vs Target", fontsize=20, fontweight='bold', color='maroon')
#Jobs vs Target
plt.subplot(3,3,1)
my_colors = ['Magenta', 'cyan']
sns.countplot(x='job',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Jobs vs Target', fontweight='bold', color='maroon')
plt.xlabel('Job', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')


#Marital Status vs Target
plt.subplot(3,3,2)
my_colors = ['Magenta', 'cyan']
sns.countplot(x='marital',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Marital Status vs Target', fontweight='bold', color='maroon')
plt.xlabel('Marital Status', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')


#Educational Qualification vs Target
plt.subplot(3,3,3)
my_colors = ['Magenta', 'cyan']
sns.countplot(x='education_qual',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Educational Qualification vs Target', fontweight='bold', color='maroon')
plt.xlabel('Educational Qualification', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#Month vs Target
plt.subplot(3,3,4)
my_colors = ['Magenta', 'cyan']
sns.countplot(x='mon',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Month vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Month', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#Previous Outcome vs Target
plt.subplot(3,3,5)
my_colors = ['Magenta', 'cyan']
sns.countplot(x='prev_outcome',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Previous Outcome vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Previous Outcome', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')


#Call Type vs Target
plt.subplot(3,3,6)
my_colors = ['Magenta', 'cyan']
sns.countplot(x='call_type',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Call Type vs Target', fontweight='bold', color='maroon')
plt.xlabel('Call Type', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

plt.show()

"""# **Categorical Data Vs Target**

**Jobs vs Target**

Target (No) : Blue Collar
Suscribed (Yes): Management
Marital Status vs Target

Target (No) : Married
Subscribed (Yes): Married
Educational Qualification vs Target

Target (No): Secondary
Subscribed (Yes): Secondary
Month vs Target

Target (No): May
Subscribed (Yes): May
Previous Outcome vs Target

Target (No): unknown
Subscribed (Yes): unknown
Call Type vs Target

Target (No): Cellular
Subscribed (Yes): Cellular

### **Categorical Data Vs Target**
**Jobs vs Target**

*   Target (No) : Blue Collar
*   Suscribed (Yes): Management

**Marital Status vs Target**

*   Target (No) : Married
*   Subscribed (Yes): Married

**Educational Qualification vs Target**

*   Target (No): Secondary
*   Subscribed (Yes): Secondary

**Month vs Target**

*   Target (No): May
*   Subscribed (Yes): May

**Previous Outcome vs Target**

*   Target (No): unknown
*   Subscribed (Yes): unknown

**Call Type vs Target**

*   Target (No): Cellular
*   Subscribed (Yes): Cellular

# **Feature VS Target Distribution - Percentage of people Subscribed**
"""

plt.figure(figsize=(20,35), dpi=180)
#plt.suptitle("Categorical Data Vs Target", fontsize=20, fontweight='bold', color='maroon')

#Jobs vs Target
plt.subplot(3,3,1)
(df.groupby('job')['target'].mean()*100).sort_values().plot(kind="bar",color='cyan')
plt.xticks(rotation=50)
plt.title('Jobs vs Target', fontweight='bold', color='maroon')
plt.xlabel('Job', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')


#Marital Status vs Target
plt.subplot(3,3,2)
(df.groupby('marital')['target'].mean()*100).sort_values().plot(kind="bar",color='Magenta')
plt.xticks(rotation=50)
plt.title('Marital Status vs Target', fontweight='bold', color='maroon')
plt.xlabel('Marital Status', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')


#Educational Qualification vs Target
plt.subplot(3,3,3)
(df.groupby('education_qual')['target'].mean()*100).sort_values().plot(kind="bar",color='cyan')
plt.xticks(rotation=50)
plt.title('Educational Qualification vs Target', fontweight='bold', color='maroon')
plt.xlabel('Educational Qualification', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')


#Month vs Target
plt.subplot(3,3,4)
(df.groupby('mon')['target'].mean()*100).sort_values().plot(kind="bar",color='Magenta')
plt.xticks(rotation=50)
plt.title('Month vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Month', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')


#Call Type vs Target
plt.subplot(3,3,5)
(df.groupby('call_type')['target'].mean()*100).sort_values().plot(kind="bar",color='cyan')
plt.xticks(rotation=50)
plt.title('Call Type vs Target', fontweight='bold', color='maroon')
plt.xlabel('Call Type', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#Previous Outcome vs Target
plt.subplot(3,3,6)
(df.groupby('prev_outcome')['target'].mean()*100).sort_values().plot(kind="bar",color='Magenta')
plt.xticks(rotation=50)
plt.title('Previous Outcome vs Target', fontweight='bold', color='maroon')
plt.xlabel('Previous Outcome', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

plt.show()

"""### **Percentage of people Subscribed -- Categorical Data Vs Target (Categorical)**
**Jobs vs Target**

*   Most subscribed % : Student, retired
*   Least Subscribed % : blue-collar

**Marital Status vs Target**

*   Most subscribed % : Single
*   Least Subscribed % : Married

**Educational Qualification vs Target**

*   Most subscribed % : teritary
*   Least Subscribed % : primary

**Month vs Target**

*   Most subscribed % : March, September
*   Least Subscribed % : May

**Call Type vs Target**

*   Most subscribed % : Cellular
*   Least Subscribed % : unknown

**Previous Outcome vs Target**

*   Most subscribed % : Success
*   Least Subscribed % : unknown

### **Numerical Variable vs Target -- Age, Day, Duration, No of Calls**
"""

plt.figure(figsize=(20, 15), dpi=150)
#sub title to show title for overall plot 
plt.suptitle("Numerical Data Vs Target", fontsize=18,  fontweight='bold', color='maroon')

#Age vs Target
plt.subplot(2,2,1)
my_colors = ['Magenta', 'DarkBlue']
sns.histplot(x='age',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Age vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Age', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')
#df[['age','target']].corr()

#Day vs Target
plt.subplot(2,2,2)
my_colors = ['Magenta', 'DarkBlue']
sns.histplot(x='day',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Day vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Day', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')
#df[['day','target']].corr()

#Duration vs Target
plt.subplot(2,2,3)
my_colors = ['Magenta', 'DarkBlue']
sns.histplot(x='dur',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Duration vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Duration', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#No of Calls vs Target
plt.subplot(2,2,4)
my_colors = ['Magenta', 'DarkBlue']
sns.histplot(x='num_calls',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('No of Calls vs Target', fontweight='bold', color='maroon' )
plt.xlabel('No Of Calls', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

plt.show()

"""### **Categorical Data Vs Target**
**Jobs vs Target**

*   Target (No) : Blue Collar
*   Suscribed (Yes): Management

**Marital Status vs Target**

*   Target (No) : Married
*   Subscribed (Yes): Married

**Educational Qualification vs Target**

*   Target (No): Secondary
*   Subscribed (Yes): Secondary

**Month vs Target**

*   Target (No): May
*   Subscribed (Yes): May

**Previous Outcome vs Target**

*   Target (No): unknown
*   Subscribed (Yes): unknown

**Call Type vs Target**

*   Target (No): Cellular
*   Subscribed (Yes): Cellular

### **Feature VS Target Distribution - Percentage of people Subscribed**
"""

plt.figure(figsize=(20,35), dpi=180)
#plt.suptitle("Categorical Data Vs Target", fontsize=20, fontweight='bold', color='maroon')

#Jobs vs Target
plt.subplot(3,3,1)
(df.groupby('job')['target'].mean()*100).sort_values().plot(kind="bar",color='cyan')
plt.xticks(rotation=50)
plt.title('Jobs vs Target', fontweight='bold', color='maroon')
plt.xlabel('Job', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#Marital Status vs Target
plt.subplot(3,3,2)
(df.groupby('marital')['target'].mean()*100).sort_values().plot(kind="bar",color='Magenta')
plt.xticks(rotation=50)
plt.title('Marital Status vs Target', fontweight='bold', color='maroon')
plt.xlabel('Marital Status', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#Educational Qualification vs Target
plt.subplot(3,3,3)
(df.groupby('education_qual')['target'].mean()*100).sort_values().plot(kind="bar",color='cyan')
plt.xticks(rotation=50)
plt.title('Educational Qualification vs Target', fontweight='bold', color='maroon')
plt.xlabel('Educational Qualification', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#Month vs Target
plt.subplot(3,3,4)
(df.groupby('mon')['target'].mean()*100).sort_values().plot(kind="bar",color='Magenta')
plt.xticks(rotation=50)
plt.title('Month vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Month', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#Call Type vs Target
plt.subplot(3,3,5)
(df.groupby('call_type')['target'].mean()*100).sort_values().plot(kind="bar",color='cyan')
plt.xticks(rotation=50)
plt.title('Call Type vs Target', fontweight='bold', color='maroon')
plt.xlabel('Call Type', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#Previous Outcome vs Target
plt.subplot(3,3,6)
(df.groupby('prev_outcome')['target'].mean()*100).sort_values().plot(kind="bar",color='Magenta')
plt.xticks(rotation=50)
plt.title('Previous Outcome vs Target', fontweight='bold', color='maroon')
plt.xlabel('Previous Outcome', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

plt.show()

"""### **Percentage of people Subscribed -- Categorical Data Vs Target (Categorical)**
**Jobs vs Target**

*   Most subscribed % : Student, retired
*   Least Subscribed % : blue-collar

**Marital Status vs Target**

*   Most subscribed % : Single
*   Least Subscribed % : Married

**Educational Qualification vs Target**

*   Most subscribed % : teritary
*   Least Subscribed % : primary

**Month vs Target**

*   Most subscribed % : March, September
*   Least Subscribed % : May

**Call Type vs Target**

*   Most subscribed % : Cellular
*   Least Subscribed % : unknown

**Previous Outcome vs Target**

*   Most subscribed % : Success
*   Least Subscribed % : unknown

### **Numerical Variable vs Target -- Age, Day, Duration, No of Calls**
"""

plt.figure(figsize=(20, 15), dpi=150)
#sub title to show title for overall plot 
plt.suptitle("Numerical Data Vs Target", fontsize=18,  fontweight='bold', color='maroon') 

#Age vs Target
plt.subplot(2,2,1)
my_colors = ['Magenta', 'DarkBlue']
sns.histplot(x='age',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Age vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Age', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')
#df[['age','target']].corr()

#Day vs Target
plt.subplot(2,2,2)
my_colors = ['Magenta', 'DarkBlue']
sns.histplot(x='day',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Day vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Day', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')
#df[['day','target']].corr()

#Duration vs Target
plt.subplot(2,2,3)
my_colors = ['Magenta', 'DarkBlue']
sns.histplot(x='dur',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('Duration vs Target', fontweight='bold', color='maroon' )
plt.xlabel('Duration', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

#No of Calls vs Target
plt.subplot(2,2,4)
my_colors = ['Magenta', 'DarkBlue']
sns.histplot(x='num_calls',hue='y',data=df, palette=my_colors)
plt.xticks(rotation=50)
plt.title('No of Calls vs Target', fontweight='bold', color='maroon' )
plt.xlabel('No Of Calls', color='DarkGreen')
plt.ylabel('y', color='DarkGreen')

plt.show()

"""### **Percentage of people Subscribed -- Categorical Data Vs Target (Categorical)**
**Jobs vs Target**

*   Most subscribed % : Student, retired
*   Least Subscribed % : blue-collar

**Marital Status vs Target**

*   Most subscribed % : Single
*   Least Subscribed % : Married

**Educational Qualification vs Target**

*   Most subscribed % : teritary
*   Least Subscribed % : primary

**Month vs Target**

*   Most subscribed % : March, September
*   Least Subscribed % : May

**Call Type vs Target**

*   Most subscribed % : Cellular
*   Least Subscribed % : unknown

**Previous Outcome vs Target**

*   Most subscribed % : Success
*   Least Subscribed % : unknown

### **Numerical Variable vs Target -- Age, Day, Duration, No of Calls**

### **Numeric Data vs Target**

**Age vs Target**

*   Target : Middle age people
*   Subscribed : Middle age people

**Day vs Target**

*   Target : Middle of Month
*   Subscribed : Middle of Month

**Duration vs Target**

*  Duration of call is also important to subscribe for insurance.

**No of Calls vs Target**

*  No of calls increase subscrition also getting increase.

# **Encoding**
In this project i am going to use decision tree so we muct do label encoding.

# **Job**
"""

#Encoding for job column (Label Encoding)
df['job']=df['job'].map({'blue-collar':1,'entrepreneur':2,'services':3,'housemaid':4,'technician':5,'self-employed':6,'admin.':7,'management':8, 'unemployed':9, 'retired': 10, 'student' : 11})   
df.head(3)

"""### **Marital Status**"""

#Encoding for Marital status (Label Encoding)
df['marital'] =df['marital'].map({'married': 1, 'divorced': 2, 'single' : 3})
df.head(3)

"""### **Educational Qualification**"""

#encoding for educational qualification (Label Encoding)
df['education_qual'] = df['education_qual'].map({'primary': 1, 'secondary': 2, 'tertiary' :3})
df.head(3)

"""### **Month**"""

# Encoding for month column (Label Encoding)
df['mon']=df['mon'].map({'may': 1, 'jul' : 2, 'jan': 3, 'nov': 4, 'jun' : 5, 'aug' : 6, 'feb' : 7, 'apr' : 8, 'oct' : 9, 'dec' : 10 , 'sep': 11, 'mar': 12})
df.head(3)

"""**Call Type**"""

# Encoding for call type column (Label Encoding)
df['call_type'] = df['call_type'].map({'unknown': 1, 'telephone' : 2, 'cellular' : 3})
df.head(3)

"""### **Previous Outcome**"""

# Encoding for previous outcome column (Label Encoding)
df['prev_outcome']=df['prev_outcome'].map({'unknown' : 1, 'failure' : 2, 'other' : 3, 'success': 4})
df.head(3)

"""# **Feature and Target Selection**"""

df.columns

# X --> Feature y-- > Target

x = df[['age', 'job', 'marital', 'education_qual', 'call_type', 'day', 'mon', 'dur', 'num_calls', 'prev_outcome']].values
y=df['target'].values

"""# **Spliting**"""

# splitting the data as train and test

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2,random_state = 3 )

"""# **Balancing**"""

#Balancing the data
from imblearn.combine import SMOTEENN 
smt = SMOTEENN(sampling_strategy='all') 
x_train_smt, y_train_smt = smt.fit_resample(x_train, y_train)

print(len(x_train_smt))
print(len(y_train_smt))

"""# **Scaling**"""

#scaling the data
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
x_train_scaled = scaler.fit_transform(x_train_smt)
x_test_scaled = scaler.transform(x_test)

"""# **Modelling**

## **Logistic Regression**
"""

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score

lr = LogisticRegression()

lr.fit(x_train_scaled,y_train_smt)
lr.score(x_test_scaled,y_test)

y_pred=lr.predict_proba(x_test_scaled)
y_pred

log_reg_auroc = roc_auc_score(y_test,y_pred[:,1])
print("AUROC score for logistic regression  :  ",round(log_reg_auroc,2))

"""## **K-Nearest Neighbour (KNN)**"""

from sklearn.neighbors import KNeighborsClassifier 
from sklearn.model_selection import cross_val_score 
for i in [1,2,3,4,5,6,7,8,9,10,20,30,40,50]: 
  knn= KNeighborsClassifier(i)
  knn.fit(x_train_scaled, y_train_smt) 
  print("K value :", i, "Train Score : ", knn.score(x_train_scaled,y_train_smt), "Cross Value Accuracy :" , np.mean(cross_val_score(knn, x_test_scaled, y_test, cv=10)))

"""**k=10 is a good cross validation accuracy of 0.895**"""

knn= KNeighborsClassifier(i)
knn.fit(x_train_scaled, y_train_smt)
print("KNN Score: ",knn.score(x_test_scaled,y_test)) 
print( "AUROC on the sampled dataset : ",roc_auc_score( y_test, knn.predict_proba(x_test)[:, 1]))

"""## **Decision Tree**"""

from sklearn.tree import DecisionTreeClassifier 
from sklearn.metrics import roc_auc_score 
dt = DecisionTreeClassifier() 
dt.fit(x_train_smt,y_train_smt) 
print("Decision Tree Score : ", dt.score(x_train_smt,y_train_smt)) 
print( "AUROC on the sampled dataset : ",roc_auc_score( y_test, dt.predict_proba(x_test)[:, 1]))

from sklearn.metrics import accuracy_score, roc_auc_score
from sklearn.model_selection import cross_val_score #this will help me to do cross- validation
import numpy as np

for depth in [1,2,3,4,5,6,7,8,9,10,20]:
  dt = DecisionTreeClassifier(max_depth=depth) # will tell the DT to not grow past the given threhsold
  # Fit dt to the training set
  dt.fit(x_train_smt, y_train_smt) # the model is trained
  trainAccuracy = accuracy_score(y_train_smt, dt.predict(x_train_smt)) # this is useless information - i am showing to prove a point
  dt = DecisionTreeClassifier(max_depth=depth) # a fresh model which is not trained yet
  valAccuracy = cross_val_score(dt, x_test_scaled, y_test, cv=10) # syntax : cross_val_Score(freshModel,fts, target, cv= 10/5)
  print("Depth  : ", depth, " Training Accuracy : ", trainAccuracy, " Cross val score : " ,np.mean(valAccuracy))

"""**k= 5 is the good cross validation score of 0.896**

## **XG Boost**
"""

import xgboost as xgb
from sklearn.model_selection import cross_val_score 
import numpy as np 
for lr in [0.01,0.02,0.03,0.04,0.05,0.1,0.11,0.12,0.13,0.14,0.15,0.2,0.5,0.7,1]: 
  model = xgb.XGBClassifier(learning_rate = lr, n_estimators=100, verbosity = 0) # initialise the model 
  model.fit(x_train_smt,y_train_smt) #train the model 
  print("Learning rate : ", lr," Train score : ", model.score(x_train_smt,y_train_smt)," Cross-Val score : ", np.mean(cross_val_score(model, x_test, y_test, cv=10)))

"""## **Random Forest**"""

from sklearn.ensemble import RandomForestClassifier
rf= RandomForestClassifier(max_depth=2,n_estimators=100,max_features="sqrt")    #max_depth=log(no of features)
rf.fit(x_train, y_train)
y_pred= rf.predict(x_test)

#doing cross validation to get best value of max _depth to prevent overfitted model 
from sklearn.model_selection import cross_val_score 
from sklearn.ensemble import RandomForestClassifier
for depth in [1,2,3,4,5,6,7,8,9,10]:
  rf= RandomForestClassifier(max_depth=depth,n_estimators=100,max_features="sqrt")   # will tell the DT to not grow past the given threhsold
  # Fit dt to the training set
  rf.fit(x_train, y_train) # the model is trained
  rf= RandomForestClassifier(max_depth=depth,n_estimators=100,max_features="sqrt")   # a fresh model which is not trained yet
  valAccuracy = cross_val_score(rf, x_train, y_train, cv=10) # syntax : cross_val_Score(freshModel,fts, target, cv= 10/5)
  print("Depth  : ", depth, " Training Accuracy : ", trainAccuracy, " Cross val score : " ,np.mean(valAccuracy))

"""**Depth = 8 is giving the good cross validation score fo 0.904**

# **Solution Statement**

Models are tested, below are the AUROC value of each model

*   **Logistic Regression** - AUROC Score is **0.88** 
*   **KNN** - AUROC Score is  **0.895**
*   **Decision Tree** - AUROC Score is **0.897**
*   **XG Boost** - AUROC Score is  **0.899**
*   **Random Forest** - AUROC Score is **0.904**

**Hence Random Forest is giving the good AUROC Score of 0.904, so Random Forest is the best model for customer convertion prediction**

# **Feature Importance**
"""

from xgboost import plot_importance

# plot feature importance
plot_importance(model)
plt.show()

df.columns

"""f0 - Age, f1 - Job, f2 - marital status, f3- educational qualification, 
f4 - call type, f5 - day, f6 - mon, f7 -dur, f8 - number of calls, 
f9 - previous outcome f10 - y

### **Conclusion:**

Based on the Feature Importance given by best machine Learning that will predict if a client subscribed to the insurance.

The client should focused on the top few features of order given below to have them subscribed to the insurance.

*   Duration - Longer the call better influncing the clients
*   Age - Age of the person plays an important role in insurance. Middle age people are targeted more and people who suscribed to insurance also middle age people.  
*   Day - People who subscribed to insurance are mostly mid of the month.
*   Month - In the month of may people subscribed to insurance are more.
*   Job - In this blue collar people are targeted more but people who subscribed more are from management job.
"""